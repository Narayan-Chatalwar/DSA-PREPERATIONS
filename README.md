# DSA-PREPERATIONS
Detailed analysis on mostly asked interview questions.

## üìö Arrays

1. Two Sum
2. Best Time to Buy and Sell Stock
3. Find Duplicates
4. Product of Array Except Self
5. Maximum Subarray (Kadane's Algorithm)
6. Maximum Product Subarray
7. Minimum in Rotated Sorted Array
8. Search in Rotated Sorted Array
9. 3Sum
10. Container With Most Water
11. Trapping Rain Water
12. Merge Intervals
13. Insert Interval
14. Non-overlapping Intervals
15. Chocolate Distribution Problem
16. Factorial of a Large Number
17. Rearrange Array Alternately
18. Sort an Array of 0s, 1s and 2s
19. Equilibrium Point
20. Leaders in an Array
21. Minimum Platforms
22. Reverse Array in Groups
23. Kth Smallest Element
24. Pythagorean Triplet
25. Convert Array into Zig-Zag Fashion
26. Last Index of 1
27. Spirally Traversing a Matrix
28. Largest Number Formed from an Array
29. Subarray with Given Sum
30. Count the Triplets
31. Missing Number in Array
32. Merge Two Sorted Arrays
33. Number of Pairs with Given Sum
34. Inversion of Array
35. Element with Left Side Smaller and Right Side Greater
36. Stock Buy and Sell
37. Maximum of All Subarrays of Size K
38. Find the Duplicate Number
39. Maximum Sum Circular Subarray
40. Longest Consecutive Sequence

## üßµ Strings

1. Reverse Words in a Given String
2. Permutations of a Given String
3. Longest Palindromic Substring
4. Recursively Remove All Adjacent Duplicates
5. Check if String is Rotated by Two Places
6. Roman Number to Integer
7. Anagram Check
8. Remove Duplicates
9. Form a Palindrome
10. Longest Substring Without Repeating Characters
11. Implement Atoi
12. Implement strstr
13. Longest Common Prefix
14. Group Anagrams
15. Valid Palindrome
16. String Compression
17. Multiply Strings
18. Decode Ways
19. Count and Say
20. Minimum Window Substring
    
## üîó Linked Lists

1. Reverse a Linked List
2. Detect Cycle in a Linked List
3. Merge Two Sorted Lists
4. Merge K Sorted Lists
5. Remove Nth Node From End of List
6. Reorder List
7. Add Two Numbers Represented by Linked Lists
8. Middle of a Linked List
9. Delete Last Occurrence from Linked List
10. Rotate a Linked List
11. Reverse a Linked List in Groups of Given Size
12. Intersection Point in Y Shaped Linked Lists
13. Remove Loop in Linked List
14. Nth Node from End of Linked List
15. Flattening a Linked List
16. Pairwise Swap of a Linked List
17. Check if Linked List is Palindrome
18. Implement Queue using Linked List
19. Implement Stack using Linked List
20. Sort a Linked List of 0s, 1s and 2s
21. Delete Without Head Pointer
22. Copy List with Random Pointer
23. LRU Cache Implementation
24. Merge Sort for Linked List
25. Add 1 to a Number Represented as Linked List

    
## üßÆ Stack and Queue

1. Parenthesis Checker
2. Next Greater Element
3. Queue using Two Stacks
4. Stack using Two Queues
5. Get Minimum Element from Stack
6. LRU Cache
7. Circular Tour
8. First Non-Repeating Character in a Stream
9. Rotten Oranges
10. Maximum of All Subarrays of Size K
11. Evaluate Reverse Polish Notation
12. Implement Stack using Array
13. Implement Queue using Array
14. Design a Stack that Supports GetMin() in O(1) Time
15. Implement a Circular Queue


## üå≥ Trees

1. Maximum Depth of Binary Tree
2. Check if Two Trees Have Same Structure
3. Invert/Flip Binary Tree
4. Binary Tree Maximum Path Sum
5. Binary Tree Level Order Traversal
6. Serialize and Deserialize Binary Tree
7. Subtree of Another Tree
8. Construct Binary Tree from Preorder and Inorder Traversal
9. Validate Binary Search Tree
10. Kth Smallest Element in a BST
11. Lowest Common Ancestor of BST
12. Implement Trie (Prefix Tree)
13. Add and Search Word
14. Diameter of Binary Tree
15. Symmetric Tree
16. Path Sum
17. Convert Sorted Array to BST
18. Flatten Binary Tree to Linked List
19. Populating Next Right Pointers in Each Node
20. Binary Tree Right Side View

    
## üìä Heaps

1. Top K Frequent Elements
2. Find Median from Data Stream
3. Largest Triplet Product in a Stream
4. Connect N Ropes with Minimum Cost
5. Kth Largest Element in an Array
6. Merge K Sorted Lists
7. Sliding Window Maximum
8. Reorganize String
9. Find K Closest Elements
10. Task Scheduler

    
## üåê Graphs

1. Clone Graph
2. Course Schedule
3. Pacific Atlantic Water Flow
4. Number of Islands
5. Longest Consecutive Sequence
6. Snake and Ladder Problem
7. Detect Cycle in a Directed Graph
8. Bridges in a Graph
9. Check Whether a Given Graph is Bipartite or Not
10. Find Size of the Largest Region in Boolean Matrix
11. Flood Fill Algorithm
12. Strongly Connected Components
13. Topological Sorting
14. Dijkstra's Algorithm
15. Bellman-Ford Algorithm
16. Kruskal's Algorithm
17. Prim's Algorithm
18. Word Ladder
19. Alien Dictionary
20. Minimum Spanning Tree

    
## üìà Dynamic Programming

1. Count Ways to Reach the Nth Stair
2. Coin Change
3. 0/1 Knapsack Problem
4. Longest Increasing Subsequence
5. Longest Common Subsequence
6. Word Break Problem
7. Dice Throw
8. Egg Dropping Puzzle
9. Matrix Chain Multiplication
10. Combination Sum
11. Subset Sum Problem
12. Find Maximum Possible Stolen Value from Houses
13. Count Possible Decodings of a Given Digit Sequence
14. Unique Paths in a Grid with Obstacles
15. Jump Game
16. Cutting a Rod
17. Maximum Product Cutting
18. Count Number of Ways to Cover a Distance
19. Palindromic Substrings
20. Edit Distance
21. Minimum Path Sum
22. Partition Equal Subset Sum
23. House Robber
24. Best Time to Buy and Sell Stock with Cooldown
25. Interleaving String
26. Scramble String
27. Distinct Subsequences
28. Arithmetic Slices
29. Decode Ways II
30. Minimum Number of Refueling Stops


## üßÆ Bit Manipulation

1. Number of 1 Bits
2. Counting Bits
3. Missing Number
4. Reverse Bits
5. Find XOR of All Subsets of a Set
6. Single Number
7. Single Number II
8. Power of Two
9. Counting Set Bits
10. Binary Watch
11. Bitwise AND of Numbers Range
12. Subsets
13. Maximum XOR of Two Numbers in an Array
14. Sum of Two Integers
15. Bitwise Complement
16. Hamming Distance
17. Total Hamming Distance
18. UTF-8 Validation
19. Convert Integer to the Sum of Two No-Zero Integers
20. XOR Queries of a Subarray



# 1. Two Sum

---

## Problem Statement

Given an array of integers `nums` and an integer `target`, **return the indices** of the two numbers in the array such that they add up to the target. Assume exactly one solution exists, and you cannot use the same element twice.

---

## Sample Input
nums = [2, 7, 11, 15], target = 9


---

## Sample Output
[0, 1]

---


## Detailed Explanation:

nums[0] + nums[1] = 2 + 7 = 9, which equals the target.


The naive approach is to check every pair to see if they sum to the target, which involves nested loops and results in O(n¬≤) time complexity.

An optimal solution uses a hash map (object in JavaScript):

Iterate through the array once.
For each number, calculate the complement needed to reach the target (complement = target - nums[i]).
Check if this complement exists in the map.
If yes, return the indices immediately.
If no, add the current number and its index to the map.



## solution 1 (Using Hashmap)
Time: O(n) ‚Äî single pass.

Space: O(n) ‚Äî store all numbers in map.

```js 

function twoSum(nums, target) {
  const map = new Map();

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
  return [];
}


```
## solution 2 (Using two pointers)
Time: O(n log n) due to sorting.

Space: O(n) for the mapped array, but you can mutate original array if allowed to avoid extra space.

```js 

function twoSum(nums, target) {
  const numsWithIndex = nums.map((num, idx) => ({ num, idx }));
  numsWithIndex.sort((a, b) => a.num - b.num);

  let left = 0;
  let right = numsWithIndex.length - 1;

  while (left < right) {
    const sum = numsWithIndex[left].num + numsWithIndex[right].num;
    if (sum === target) {
      return [numsWithIndex[left].idx, numsWithIndex[right].idx];
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }

  return [];
}


```
# 1. Two Sum

---

## Problem Statement

Given an array of integers `nums` and an integer `target`, **return the indices** of the two numbers in the array such that they add up to the target. Assume exactly one solution exists, and you cannot use the same element twice.

---

## Sample Input
nums = [2, 7, 11, 15], target = 9


---

## Sample Output
[0, 1]

---


## Detailed Explanation:

nums[0] + nums[1] = 2 + 7 = 9, which equals the target.


The naive approach is to check every pair to see if they sum to the target, which involves nested loops and results in O(n¬≤) time complexity.

An optimal solution uses a hash map (object in JavaScript):

Iterate through the array once.
For each number, calculate the complement needed to reach the target (complement = target - nums[i]).
Check if this complement exists in the map.
If yes, return the indices immediately.
If no, add the current number and its index to the map.



## solution 1 (Using Hashmap)
Time: O(n) ‚Äî single pass.

Space: O(n) ‚Äî store all numbers in map.

```js 

function twoSum(nums, target) {
  const map = new Map();

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
  return [];
}


```
## solution 2 (Using two pointers)
Time: O(n log n) due to sorting.

Space: O(n) for the mapped array, but you can mutate original array if allowed to avoid extra space.

```js 

function twoSum(nums, target) {
  const numsWithIndex = nums.map((num, idx) => ({ num, idx }));
  numsWithIndex.sort((a, b) => a.num - b.num);

  let left = 0;
  let right = numsWithIndex.length - 1;

  while (left < right) {
    const sum = numsWithIndex[left].num + numsWithIndex[right].num;
    if (sum === target) {
      return [numsWithIndex[left].idx, numsWithIndex[right].idx];
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }

  return [];
}


```

